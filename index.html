<html lang="en">
<head>
    <title>Play</title>
    <style>
        html, body { height: 100%; margin: 0; overflow: hidden; font-family: "Courier New", monospace; }
        #c { width: 100%; height: 100%; display: block; }
        #overlay {
            position: absolute;
            z-index: 2;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0);
        }
        #overlay button {
            background: rgba(0, 0, 0, 0); border: 0;
            color: #808080; padding: 16px 20px;
            text-transform: uppercase; cursor: pointer;
			      font-family: "Courier New", monospace;
			      font-size: 60px;
        }
        #loading-screen {
            position: absolute;
            z-index: 3;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 255);
            color: #808080;
            font-size: 60px;
            font-family: "Courier New", monospace;
        }
        #info {
            position: absolute; 
            top: 0px; 
            width: 100%;
            padding: 10px; 
            box-sizing: border-box;
            text-align: center; 
            user-select: none;
            pointer-events: none; 
            z-index: 1;
            color: #ffffff;
            font-size: 14px;
            white-space: nowrap;
            overflow: visible;
        }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="overlay"><button id="startButton">1. Accept Mic & Webcam Request <br> 2. Click to Play</button></div>
<div id="loading-screen">10</div>
<script type="module">
    import * as THREE from "https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js";
    import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/controls/PointerLockControls.js';
    import { CSS3DRenderer, CSS3DObject } from 'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/renderers/CSS3DRenderer.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/loaders/DRACOLoader.js';
    import { Box3 } from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js';
    import { PositionalAudioHelper } from 'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/helpers/PositionalAudioHelper.js';

    const startButton = document.getElementById('startButton');
    const loadingScreen = document.getElementById('loading-screen');
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const analyser = audioContext.createAnalyser();
    let sceneReady = false;
  
    startButton.addEventListener('click', init);

  async function init() {
        document.getElementById("overlay").remove();
        loadingScreen.style.display = 'flex';
      
        // Start the loading countdown
        let countdown = 10;
        const countInterval = setInterval(() => {
            countdown--;
            loadingScreen.textContent = countdown;
            
            if (countdown <= 0) {
                clearInterval(countInterval);
                loadingScreen.textContent = "m@ke s0me n0ise";
                setTimeout(() => {
                    loadingScreen.textContent = "m@ke s0me no!se";
                    setTimeout(() => {
                        loadingScreen.textContent = "m@ke s0me N0ise";
                            setTimeout(() => {
                                loadingScreen.textContent = "m@ke s0me n0!se";
                                    setTimeout(() => {
                                        loadingScreen.textContent = "m@ke s0me n0ise";
                                            setTimeout (() => {
                                                loadingScreen.style.display = 'none';
                                            }, 200); // fifth message duration
                                    }, 70); // fourth message duration
                            }, 300); // third message duration
                    }, 80); // second message duration
                 }, 400); // first message duration
            }
        }, 1000);

      
       // Add gamepad listener
        window.addEventListener("gamepadconnected", (event) => {
        console.log("Gamepad connected:", event.gamepad);
      });

        window.addEventListener("gamepaddisconnected", (event) => {
        console.log("Gamepad disconnected:", event.gamepad);
      });
      
      //

        const canvas = document.getElementById("c");
        const renderer = new THREE.WebGLRenderer({ canvas });
        const cssRenderer = new CSS3DRenderer();
        cssRenderer.setSize(window.innerWidth, window.innerHeight);
        cssRenderer.domElement.style.position = 'absolute';
        cssRenderer.domElement.style.top = 0;
        document.body.appendChild(cssRenderer.domElement);

        const clock = new THREE.Clock();
        const scene = new THREE.Scene();
        const cssScene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 1, 3500);
   //     camera.position.set(1550, 30, -700);  //actual camera starting position for game
     camera.position.set(-1450, 30, 700);

        const controls = new PointerLockControls(camera, renderer.domElement);
        const listener = new THREE.AudioListener();
        const threeJsAudioContext = listener.context;
        camera.add(listener);

        const positionalAudioAnalyser = threeJsAudioContext.createAnalyser();
        positionalAudioAnalyser.fftSize = 2048;

        document.addEventListener('click', () => controls.lock());
      
     

        const move = { forward: false, backward: false, left: false, right: false };

        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': move.forward = true; break;
                case 'ArrowDown': case 'KeyS': move.backward = true; break;
                case 'ArrowLeft': case 'KeyA': move.left = true; break;
                case 'ArrowRight': case 'KeyD': move.right = true; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': move.forward = false; break;
                case 'ArrowDown': case 'KeyS': move.backward = false; break;
                case 'ArrowLeft': case 'KeyA': move.left = false; break;
                case 'ArrowRight': case 'KeyD': move.right = false; break;
            }
        });

        // Generate random color for the GridHelper
        function getRandomColor() {
            const color = Math.floor(Math.random() * 0xffffff);
            return color;
        }

        const gridHelper = new THREE.GridHelper(20000, 200, getRandomColor(), getRandomColor());
      //  scene.add(gridHelper);

        function generateRandomString(length) {
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return result;
        }
           
      
      const geometry = new THREE.BoxGeometry( 40, 200, 2830 ); 
        const material = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube = new THREE.Mesh( geometry, material ); 
        cube.position.set(-1330, 50, 40);
        cube.userData.collidable = true;
        scene.add( cube );
      
      const geometry2 = new THREE.BoxGeometry( 40, 200, 2920 ); 
        const material2 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube2 = new THREE.Mesh( geometry2, material2 ); 
        cube2.position.set(-1620, 50, -170);
        cube2.userData.collidable = true;
        scene.add( cube2 );
      
      const geometry3 = new THREE.BoxGeometry( 3420, 200, 300 ); 
        const material3 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube3 = new THREE.Mesh( geometry3, material3 ); 
        cube3.position.set(0, 50, -1610);
        cube3.userData.collidable = true;
        scene.add( cube3 );
      
      const geometry4 = new THREE.BoxGeometry( 2880, 200, 40 ); 
        const material4 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube4 = new THREE.Mesh( geometry4, material4 ); 
        cube4.position.set(100, 50, -1360);
        cube4.userData.collidable = true;
        scene.add( cube4 );
      
      const geometry5 = new THREE.BoxGeometry( 1145, 230, 200 ); 
        const material5 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube5 = new THREE.Mesh( geometry5, material5 ); 
        cube5.position.set(-1780, 70, 1530);
        cube5.userData.collidable = true;
        scene.add( cube5 );
      
     const geometry6 = new THREE.BoxGeometry( 100, 200, 6670 ); 
        const material6 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube6 = new THREE.Mesh( geometry6, material6 ); 
        cube6.position.set(1490, 50, 1960);
        cube6.userData.collidable = true;
        scene.add( cube6 );
    
        const geometry7 = new THREE.BoxGeometry( 100, 200, 9370 ); 
        const material7 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube7 = new THREE.Mesh( geometry7, material7 ); 
        cube7.position.set(1610, 50, 2000);
        cube7.userData.collidable = true;
        scene.add( cube7 );
    /*  
        const geometry8 = new THREE.BoxGeometry( 100, 200, 200 ); 
        const material8 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube8 = new THREE.Mesh( geometry8, material8 ); 
        cube8.position.set(1540, 50, -450);
        cube8.userData.collidable = true;
        scene.add( cube8 );
    */  
        const geometry9 = new THREE.BoxGeometry( 1145, 230, 40 ); 
        const material9 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube9 = new THREE.Mesh( geometry9, material9 ); 
        cube9.position.set(-2180, 70, 1280);
        cube9.userData.collidable = true;
        scene.add( cube9 );
      
        const geometry10 = new THREE.BoxGeometry( 40, 230, 4100 ); 
        const material10 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube10 = new THREE.Mesh( geometry10, material10 ); 
        cube10.position.set(-2600, 70, 3200);
        cube10.userData.collidable = true;
        scene.add( cube10 );
      
        const geometry11 = new THREE.BoxGeometry( 40, 230, 3800 ); 
        const material11 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube11 = new THREE.Mesh( geometry11, material11 ); 
        cube11.position.set(-2340, 70, 3500);
        cube11.userData.collidable = true;
        scene.add( cube11 );
      
        const geometry12 = new THREE.BoxGeometry( 840, 230, 100 ); 
        const material12 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube12 = new THREE.Mesh( geometry12, material12 ); 
        cube12.position.set(-2325, 70, 5370);
        cube12.userData.collidable = true;
        scene.add( cube12 );
      
        const geometry13 = new THREE.BoxGeometry( 440, 230, 100 ); 
        const material13 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube13 = new THREE.Mesh( geometry13, material13 ); 
        cube13.position.set(-2800, 70, 5250);
        cube13.userData.collidable = true;
        scene.add( cube13 );
      
        const geometry14 = new THREE.BoxGeometry( 300, 230, 840 ); 
        const material14 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube14 = new THREE.Mesh( geometry14, material14 ); 
        cube14.position.set(-3000, 70, 5300);
        cube14.userData.collidable = true;
        scene.add( cube14 );
      
        const geometry15 = new THREE.BoxGeometry( 3490, 230, 100 ); 
        const material15 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube15 = new THREE.Mesh( geometry15, material15 ); 
        cube15.position.set(-225, 70, 5370);
        cube15.userData.collidable = true;
        scene.add( cube15 );
      
        const geometry16 = new THREE.BoxGeometry( 5200, 230, 100 ); 
        const material16 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0} ); 
        const cube16 = new THREE.Mesh( geometry16, material16 ); 
        cube16.position.set(-225, 70, 5600);
        cube16.userData.collidable = true;
        scene.add( cube16 );
      
      
      // Add bounding box 1
      const greenBoxBoundingBox = new THREE.Box3().setFromObject(cube);
      const greenBoxHelper = new THREE.BoxHelper(cube, 0xffff00);
//     scene.add(greenBoxHelper);
      
       // Add bounding box 2
      const redBoxBoundingBox = new THREE.Box3().setFromObject(cube2);
      const redBoxHelper = new THREE.BoxHelper(cube2, 0xff0000);
//      scene.add(redBoxHelper);
      
        // Add bounding box 3
      const boundingBox3 = new THREE.Box3().setFromObject(cube3);
      const boundingBox3Helper = new THREE.BoxHelper(cube3, 0xff0000);
  //    scene.add(boundingBox3Helper);
      
        // Add bounding box 4
      const boundingBox4 = new THREE.Box3().setFromObject(cube4);
      const boundingBox4Helper = new THREE.BoxHelper(cube4, 0xff0000);
//     scene.add(boundingBox4Helper);
      
        // Add bounding box 5
      const boundingBox5 = new THREE.Box3().setFromObject(cube5);
      const boundingBox5Helper = new THREE.BoxHelper(cube5, 0xff0000);
 //    scene.add(boundingBox5Helper);
      
       // Add bounding box 6
      const boundingBox6 = new THREE.Box3().setFromObject(cube6);
      const boundingBox6Helper = new THREE.BoxHelper(cube6, 0xff0000);
  //    scene.add(boundingBox6Helper);
      
      
      // Add bounding box 7
      const boundingBox7 = new THREE.Box3().setFromObject(cube7);
      const boundingBox7Helper = new THREE.BoxHelper(cube7, 0xff0000);
  //    scene.add(boundingBox7Helper);
 /*     
       // Add bounding box 8
      const boundingBox8 = new THREE.Box3().setFromObject(cube8);
      const boundingBox8Helper = new THREE.BoxHelper(cube8, 0xff0000);
 //    scene.add(boundingBox8Helper);
 */     
         // Add bounding box 9
      const boundingBox9 = new THREE.Box3().setFromObject(cube9);
      const boundingBox9Helper = new THREE.BoxHelper(cube9, 0xff0000);
//     scene.add(boundingBox9Helper);
      
       // Add bounding box 10
      const boundingBox10 = new THREE.Box3().setFromObject(cube10);
      const boundingBox10Helper = new THREE.BoxHelper(cube10, 0xff0000);
 //    scene.add(boundingBox10Helper);
      
      // Add bounding box 11
      const boundingBox11 = new THREE.Box3().setFromObject(cube11);
      const boundingBox11Helper = new THREE.BoxHelper(cube11, 0xff0000);
  //   scene.add(boundingBox11Helper);
      
      
        // Add bounding box 12
      const boundingBox12 = new THREE.Box3().setFromObject(cube12);
      const boundingBox12Helper = new THREE.BoxHelper(cube12, 0xff0000);
  //   scene.add(boundingBox12Helper);
      
       // Add bounding box 13
      const boundingBox13 = new THREE.Box3().setFromObject(cube13);
      const boundingBox13Helper = new THREE.BoxHelper(cube13, 0xff0000);
 //    scene.add(boundingBox13Helper);
      
        // Add bounding box 14
      const boundingBox14 = new THREE.Box3().setFromObject(cube14);
      const boundingBox14Helper = new THREE.BoxHelper(cube14, 0xff0000);
 //   scene.add(boundingBox14Helper);
      
       // Add bounding box 15
      const boundingBox15 = new THREE.Box3().setFromObject(cube15);
      const boundingBox15Helper = new THREE.BoxHelper(cube15, 0xff0000);
  //  scene.add(boundingBox15Helper);
      
      // Add bounding box 16
      const boundingBox16 = new THREE.Box3().setFromObject(cube16);
      const boundingBox16Helper = new THREE.BoxHelper(cube16, 0xff0000);
 //    scene.add(boundingBox16Helper);
    
      // Add bounding box for the camera
      const cameraBoundingBox = new THREE.Box3();
      const cameraBoundingHelperGeometry = new THREE.BoxGeometry(5, 5, 5); 
      const cameraBoundingHelperMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true }); // Red wireframe
      const cameraBoundingHelper = new THREE.Mesh(cameraBoundingHelperGeometry, cameraBoundingHelperMaterial);
   //   scene.add(cameraBoundingHelper);

      function updateBoundingBoxes() {
          // Update camera bounding box position to match the camera
          const cameraPosition = camera.position.clone();
          cameraBoundingHelper.position.copy(cameraPosition);
          cameraBoundingBox.setFromObject(cameraBoundingHelper);
      }
      

     
      //load 3d model of bell with animation
        const loader = new GLTFLoader();
        loader.setPath('');
        let mixer;
      
        loader.load('bell-ascii.glb', function (gltf) {
            gltf.scene.position.set(-900, -125, -1350);
            gltf.scene.scale.set(1000, 75, 125);
            gltf.scene.rotation.set(0, 0, 0);
            scene.add(gltf.scene);
       
        mixer = new THREE.AnimationMixer(gltf.scene);
        
        gltf.animations.forEach((clip) => {
        const action = mixer.clipAction(clip);
        action.setEffectiveTimeScale(0); // 0.5 for half speed, 2.0 for double speed
        action.play();
          });
        });
      
      
      //load 3d model of bell2 with animation
        const loaderBell2 = new GLTFLoader();
        loaderBell2.setPath('');
        let mixer2;
      
        loaderBell2.load('bell-ascii.glb', function (gltf) {
            gltf.scene.position.set(-2430, 400, 3200);
            gltf.scene.scale.set(135, 150, 1000);
            gltf.scene.rotation.set(0, -1/41 * Math.PI, -Math.PI);
            scene.add(gltf.scene);
       
        mixer2 = new THREE.AnimationMixer(gltf.scene);
        
        gltf.animations.forEach((clip) => {
        const action = mixer2.clipAction(clip);
        action.setEffectiveTimeScale(0); // 0.5 for half speed, 2.0 for double speed
        action.play();
          });
        });


        //load 3d model of bell3 with animation
        const loaderBell3 = new GLTFLoader();
        loaderBell3.setPath('');
        let mixer3;
      
        loaderBell3.load('the_accumoli_bell_animated_glitch_32_copy.glb', function (gltf) {
            gltf.scene.position.set(-1450, -100, 1000);
            gltf.scene.scale.set(200, 200, 200);
            gltf.scene.rotation.set(Math.PI/4, 0, 0);
            scene.add(gltf.scene);
       
        mixer3 = new THREE.AnimationMixer(gltf.scene);
        
        gltf.animations.forEach((clip) => {
        const action = mixer3.clipAction(clip);
        action.setEffectiveTimeScale(1); // 0.5 for half speed, 2.0 for double speed
        action.play();
          });
        });

            // Create a DRACOLoader instance
        const dracoLoader = new DRACOLoader();
        // Specify the path to the Draco decoder
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');

        // Create GLTFLoader and attach DRACOLoader
        const loaderBell4 = new GLTFLoader();
        loaderBell4.setDRACOLoader(dracoLoader);
        loaderBell4.setPath('');

        let mixer4;

        loaderBell4.load('bell4-compressed.glb', function (gltf) {
            gltf.scene.position.set(0, -500, 5250);
            gltf.scene.scale.set(200, 200, 200);
            gltf.scene.rotation.set(0, 3*Math.PI/4, Math.PI/4);
            scene.add(gltf.scene);

            mixer4 = new THREE.AnimationMixer(gltf.scene);
            
            gltf.animations.forEach((clip) => {
                const action = mixer4.clipAction(clip);
                action.setEffectiveTimeScale(.8);
                action.play();
            });
        });

        // dispose of the decoder when done
        // dracoLoader.dispose();

         //load 3d model of bell5 with animation
         const loaderBell5 = new GLTFLoader();
        loaderBell5.setPath('');
        let mixer5;
      
        loaderBell5.load('', function (gltf) {
            gltf.scene.position.set(1550, 0, 3250);
            gltf.scene.scale.set(100, 100, 100);
            gltf.scene.rotation.set(0, 0, 0);
            scene.add(gltf.scene);
       
        mixer5 = new THREE.AnimationMixer(gltf.scene);
        
        gltf.animations.forEach((clip) => {
        const action = mixer5.clipAction(clip);
        action.setEffectiveTimeScale(1); // 0.5 for half speed, 2.0 for double speed
        action.play();
          });
        });
      
      
     //load 3d model of wooden speaker
        const loaderWoodenSpeaker = new GLTFLoader();
        loaderWoodenSpeaker.setPath('');  
        loaderWoodenSpeaker.load('hornspeaker.glb', function (gltf) {
            gltf.scene.position.set(1590, 50, 1000);
            gltf.scene.scale.set(40, 40, 40);
            gltf.scene.rotation.set(Math.PI/4, -Math.PI/4, 0);
            scene.add(gltf.scene);
        });

    //load 3d model of horn speaker
    const loaderHornSpeaker = new GLTFLoader();
    loaderHornSpeaker.setPath('');  
    loaderHornSpeaker.load('hornspeaker.glb', function (gltf) {
        gltf.scene.position.set(1500, 50, 2000);
        gltf.scene.scale.set(40, 40, 40);
        gltf.scene.rotation.set(-Math.PI/4, 3*Math.PI/4, 0);
        scene.add(gltf.scene);
    });
    
      
 
  /*    
      //load 3d model of speaker horn 1
        const loaderHorn = new GLTFLoader();
        loaderHorn.setPath('https://cdn.glitch.global/4bb80715-9a2a-437d-b131-f6f804a2598f/');  
        loaderHorn.load('loudspeakers__horn__speaker_9_mb.glb?v=1733663371454', function (gltf) {
            gltf.scene.position.set(300, 300, -1430);
            gltf.scene.scale.set(100, 100, 100);
            gltf.scene.rotation.set(Math.PI/2, -Math.PI/8, Math.PI/3);
      //      scene.add(gltf.scene);
        });
         
   */   
        const light = new THREE.HemisphereLight(0xffffff, 0x444444, 6);
        scene.add(light);
            
        const soundList = [""];
        const iframePositions = [
            [-3350, 90, 5350],  // 2
            
        ];
        const audioLoader = new THREE.AudioLoader();
      
      let hydraIframeObject = null; // declare on global level
      let hydraIframeObject2 = null;
      let hydraIframeObject3 = null;
      let hydraIframeObject4 = null;
      let hydraIframeObject5 = null;
      let hydraIframeObject6 = null;
      let hydraIframeObject7 = null;
      let hydraIframeObject8 = null;
      let hydraIframeObject9 = null;
      let hydraIframeObject10 = null;
      let hydraIframeObject11 = null;
      let hydraIframeObject12 = null;
      let hydraIframeObject13 = null;
      let hydraIframeObject14 = null;
      let hydraIframeObject15 = null;
      let hydraIframeObject16 = null;
      let hydraIframeObject17 = null;
      let hydraIframeObject18 = null;
      let hydraIframeObject19 = null;
      let hydraIframeObject20 = null;
      let hydraIframeObject21 = null;
      let hydraIframeObject22 = null;
      let hydraIframeObject23 = null;
      let hydraIframeObject24 = null;
      let hydraIframeObject25 = null;
      let hydraIframeObject26 = null;



      const LOAD_DISTANCE = 2500; // Distance at which iframes are loaded
      const UNLOAD_DISTANCE = 2500; // Distance at which iframes are unloaded

// Class to manage iframe loading states
class IframeLazyLoader {
    constructor(iframeObject, srcUrl) {
        this.iframeObject = iframeObject;
        this.srcUrl = srcUrl;
        this.isLoaded = false;
        this.div = iframeObject.element;
        this.iframe = this.div.querySelector('iframe');
        this.div.style.display = 'none';
        this.iframe.src = 'about:blank';
    }

    load() {
        if (!this.isLoaded) {
            this.iframe.src = this.srcUrl;
            this.isLoaded = true;
            this.div.style.display = 'block';
        }
    }

    unload() {
        if (this.isLoaded) {
            this.iframe.src = 'about:blank';
            this.isLoaded = false;
            this.div.style.display = 'none';
        }
    }

    // Check if iframe should be loaded based on camera position and orientation
   updateVisibility(camera) {
        const distance = camera.position.distanceTo(this.iframeObject.position);
        
        if (distance < LOAD_DISTANCE) {
            this.load();
        } else if (distance > UNLOAD_DISTANCE) {
            this.unload();
        }
    }
}

setupAudioInput();     
      
        function createIframeWithAudio(position, rotation, soundPath) {
            const iframeDiv = document.createElement('div');
            iframeDiv.style.width = '470px';
            iframeDiv.style.height = '300px';

            const iframe = document.createElement('iframe');
            iframe.src = `index.html`;  //Most browsers limit recursion. For the performance, I will configure the server so that I can create infinite recursion by adding a random string of numbers at the end of the URL.
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.border = '0';
            iframeDiv.appendChild(iframe);

            const iframeObject = new CSS3DObject(iframeDiv);
            iframeObject.position.set(...position);
            iframeObject.rotation.set(...rotation);
            iframeObject.scale.set(1, 1, 1); // increase visual size in 3D without increasing resolution
      //      cssScene.add(iframeObject);
          
         // Create Hydra iframe 5 - Hall 3, right wall
            const additionalIframeDiv5 = document.createElement('div');
            additionalIframeDiv5.style.width = '1000px';
            additionalIframeDiv5.style.height = '1000px';
            additionalIframeDiv5.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv5.style.zIndex = '-1';

            const additionalIframe5 = document.createElement('iframe');
            additionalIframe5.src = 'hydrainwebpage2.html';
            additionalIframe5.style.width = '100%';
            additionalIframe5.style.height = '100%';
            additionalIframe5.style.border = '0';
            additionalIframe5.style.pointerEvents = 'none';

            additionalIframe5.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe5.allowFullscreen = true;
            additionalIframeDiv5.appendChild(additionalIframe5);

            const additionalIframeObject5 = new CSS3DObject(additionalIframeDiv5);
            additionalIframeObject5.position.set(1530, 0, -880);
            additionalIframeObject5.rotation.set(0, -Math.PI/2, 0); // Set rotation
            additionalIframeObject5.scale.set(1, .33, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject5.renderOrder = -1; // Lower priority
            hydraIframeObject5 = additionalIframeObject5; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject5);
          
          
            // Create Hydra iframe 6 - Hall 3, left wall
            const additionalIframeDiv6 = document.createElement('div');
            additionalIframeDiv6.style.width = '1000px';
            additionalIframeDiv6.style.height = '1000px';
            additionalIframeDiv6.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv6.style.zIndex = '-1';

            const additionalIframe6 = document.createElement('iframe');
            additionalIframe6.src = 'hydrainwebpage2.html';
            additionalIframe6.style.width = '100%';
            additionalIframe6.style.height = '100%';
            additionalIframe6.style.border = '0';
            additionalIframe6.style.pointerEvents = 'none';

            additionalIframe6.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe6.allowFullscreen = true;
            additionalIframeDiv6.appendChild(additionalIframe6);

            const additionalIframeObject6 = new CSS3DObject(additionalIframeDiv6);
            additionalIframeObject6.position.set(1560, 0, -885);
            additionalIframeObject6.rotation.set(0, -Math.PI/2, 0); // Set rotation
            additionalIframeObject6.scale.set(1.15, .33, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject6.renderOrder = -1; // Lower priority
            hydraIframeObject6 = additionalIframeObject6; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject6);
          
          
          // Create Hydra iframe 1 - Right wall
            const additionalIframeDiv = document.createElement('div');
            additionalIframeDiv.style.width = '1000px';
            additionalIframeDiv.style.height = '1000px';
            additionalIframeDiv.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv.style.zIndex = '-1';

            const additionalIframe = document.createElement('iframe');
            additionalIframe.src = 'hydrainwebpage2.html';
            additionalIframe.style.width = '100%';
            additionalIframe.style.height = '100%';
            additionalIframe.style.border = '0';
            additionalIframe.style.pointerEvents = 'none';

            additionalIframe.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe.allowFullscreen = true;
            additionalIframeDiv.appendChild(additionalIframe);

            const additionalIframeObject = new CSS3DObject(additionalIframeDiv);
            additionalIframeObject.position.set(-1350, 0, 0);
            additionalIframeObject.rotation.set(0, Math.PI/2, 0); // Set rotation
            additionalIframeObject.scale.set(3, .33, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject.renderOrder = -1; // Lower priority
            hydraIframeObject = additionalIframeObject; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject);
          
          
           // Create Hydra iframe 2 - Left wall
            const additionalIframeDiv2 = document.createElement('div');
            additionalIframeDiv2.style.width = '1000px';
            additionalIframeDiv2.style.height = '1000px';
            additionalIframeDiv2.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv2.style.zIndex = '-1';

            const additionalIframe2 = document.createElement('iframe');
            additionalIframe2.src = 'hydrainwebpage2.html';
            additionalIframe2.style.width = '100%';
            additionalIframe2.style.height = '100%';
            additionalIframe2.style.border = '0';
            additionalIframe2.style.pointerEvents = 'none';

            additionalIframe2.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe2.allowFullscreen = true;
            additionalIframeDiv2.appendChild(additionalIframe2);

            const additionalIframeObject2 = new CSS3DObject(additionalIframeDiv2);
            additionalIframeObject2.position.set(-1600, 0, -300);
            additionalIframeObject2.rotation.set(0, Math.PI/2, 0); // Set rotation
            additionalIframeObject2.scale.set(3.2, .33, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject2.renderOrder = -1; // Lower priority
            hydraIframeObject2 = additionalIframeObject2; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject2);
   
          
           // Create Hydra iframe 3 - Hall 2, left wall
            const additionalIframeDiv3 = document.createElement('div');
            additionalIframeDiv3.style.width = '1000px';
            additionalIframeDiv3.style.height = '1000px';
            additionalIframeDiv3.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv3.style.zIndex = '-1';

            const additionalIframe3 = document.createElement('iframe');
            additionalIframe3.src = 'hydrainwebpage2.html';
            additionalIframe3.style.width = '100%';
            additionalIframe3.style.height = '100%';
            additionalIframe3.style.border = '0';
            additionalIframe3.style.pointerEvents = 'none';

            additionalIframe3.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe3.allowFullscreen = true;
            additionalIframeDiv3.appendChild(additionalIframe3);

            const additionalIframeObject3 = new CSS3DObject(additionalIframeDiv3);
            additionalIframeObject3.position.set(0, 0, -1460);
            additionalIframeObject3.rotation.set(0, 0, 0); // Set rotation
            additionalIframeObject3.scale.set(3.55, .33, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject3.renderOrder = -1; // Lower priority
            hydraIframeObject3 = additionalIframeObject3; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject3);
          
           // Create Hydra iframe 4 - Hall 2, right wall
            const additionalIframeDiv4 = document.createElement('div');
            additionalIframeDiv4.style.width = '1000px';
            additionalIframeDiv4.style.height = '1000px';
            additionalIframeDiv4.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv4.style.zIndex = '-1';

            const additionalIframe4 = document.createElement('iframe');
            additionalIframe4.src = 'hydrainwebpage2.html';
            additionalIframe4.style.width = '100%';
            additionalIframe4.style.height = '100%';
            additionalIframe4.style.border = '0';
            additionalIframe4.style.pointerEvents = 'none';

            additionalIframe4.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe4.allowFullscreen = true;
            additionalIframeDiv4.appendChild(additionalIframe4);

            const additionalIframeObject4 = new CSS3DObject(additionalIframeDiv4);
            additionalIframeObject4.position.set(150, 0, -1380);
            additionalIframeObject4.rotation.set(0, 0, 0); // Set rotation
            additionalIframeObject4.scale.set(3, .33, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject4.renderOrder = -1; // Lower priority
            hydraIframeObject4 = additionalIframeObject4; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject4);
          
          
            // Create Hydra iframe 11 - Hall 4 left wall
            const additionalIframeDiv11 = document.createElement('div');
            additionalIframeDiv11.style.width = '100px';
            additionalIframeDiv11.style.height = '100px';
            additionalIframeDiv11.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv11.style.zIndex = '-1';

            const additionalIframe11 = document.createElement('iframe');
            additionalIframe11.src = 'hydrainwebpage2.html';
            additionalIframe11.style.width = '100%';
            additionalIframe11.style.height = '100%';
            additionalIframe11.style.border = '0';
            additionalIframe11.style.pointerEvents = 'none';

            additionalIframe11.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe11.allowFullscreen = true;
            additionalIframeDiv11.appendChild(additionalIframe11);

            const additionalIframeObject11 = new CSS3DObject(additionalIframeDiv11);
            additionalIframeObject11.position.set(-1850, 45, 1450);
            additionalIframeObject11.rotation.set(0, 0, 0); // Set rotation
            additionalIframeObject11.scale.set(10, 2.4, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject11.renderOrder = -1; // Lower priority
            hydraIframeObject11 = additionalIframeObject11; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject11);
          
            // Create Hydra iframe 12 - Hall 4 right wall
            const additionalIframeDiv12 = document.createElement('div');
            additionalIframeDiv12.style.width = '100px';
            additionalIframeDiv12.style.height = '100px';
            additionalIframeDiv12.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv12.style.zIndex = '-1';

            const additionalIframe12 = document.createElement('iframe');
            additionalIframe12.src = 'hydrainwebpage2.html';
            additionalIframe12.style.width = '100%';
            additionalIframe12.style.height = '100%';
            additionalIframe12.style.border = '0';
            additionalIframe12.style.pointerEvents = 'none';

            additionalIframe12.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe12.allowFullscreen = true;
            additionalIframeDiv12.appendChild(additionalIframe12);

            const additionalIframeObject12 = new CSS3DObject(additionalIframeDiv12);
            additionalIframeObject12.position.set(-2100, 45, 1300);
            additionalIframeObject12.rotation.set(0, 0, 0); // Set rotation
            additionalIframeObject12.scale.set(10, 2.4, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject12.renderOrder = -1; // Lower priority
            hydraIframeObject12 = additionalIframeObject12; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject12);
          
          
            // Create Hydra iframe 13 - Hall 5 right wall
            const additionalIframeDiv13 = document.createElement('div');
            additionalIframeDiv13.style.width = '50px';
            additionalIframeDiv13.style.height = '50px';
            additionalIframeDiv13.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv13.style.zIndex = '-1';

            const additionalIframe13 = document.createElement('iframe');
            additionalIframe13.src = 'hydrainwebpage2.html';
            additionalIframe13.style.width = '100%';
            additionalIframe13.style.height = '100%';
            additionalIframe13.style.border = '0';
            additionalIframe13.style.pointerEvents = 'none';

            additionalIframe13.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe13.allowFullscreen = true;
            additionalIframeDiv13.appendChild(additionalIframe13);

            const additionalIframeObject13 = new CSS3DObject(additionalIframeDiv13);
            additionalIframeObject13.position.set(-2600, 45, 3290);
            additionalIframeObject13.rotation.set(0, Math.PI/2, 0); // Set rotation
            additionalIframeObject13.scale.set(80, 4.8, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject13.renderOrder = -1; // Lower priority
            hydraIframeObject13 = additionalIframeObject13; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject13);
          
            // Create Hydra iframe 14 - Hall 5 left wall
            const additionalIframeDiv14 = document.createElement('div');
            additionalIframeDiv14.style.width = '50px';
            additionalIframeDiv14.style.height = '50px';
            additionalIframeDiv14.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv14.style.zIndex = '-1';

            const additionalIframe14 = document.createElement('iframe');
            additionalIframe14.src = 'hydrainwebpage2.html';
            additionalIframe14.style.width = '100%';
            additionalIframe14.style.height = '100%';
            additionalIframe14.style.border = '0';
            additionalIframe14.style.pointerEvents = 'none';

            additionalIframe14.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe14.allowFullscreen = true;
            additionalIframeDiv14.appendChild(additionalIframe14);

            const additionalIframeObject14 = new CSS3DObject(additionalIframeDiv14);
            additionalIframeObject14.position.set(-2350, 45, 3400);
            additionalIframeObject14.rotation.set(0, Math.PI/2, 0); // Set rotation
            additionalIframeObject14.scale.set(78, 4.8, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject14.renderOrder = -1; // Lower priority
            hydraIframeObject14 = additionalIframeObject14; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject14);
          
              // Create Hydra iframe 15 - Hall 6 left wall
            const additionalIframeDiv15 = document.createElement('div');
            additionalIframeDiv15.style.width = '50px';
            additionalIframeDiv15.style.height = '50px';
            additionalIframeDiv15.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv15.style.zIndex = '-1';

            const additionalIframe15 = document.createElement('iframe');
            additionalIframe15.src = 'hydrainwebpage2.html';
            additionalIframe15.style.width = '100%';
            additionalIframe15.style.height = '100%';
            additionalIframe15.style.border = '0';
            additionalIframe15.style.pointerEvents = 'none';

            additionalIframe15.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe15.allowFullscreen = true;
            additionalIframeDiv15.appendChild(additionalIframe15);

            const additionalIframeObject15 = new CSS3DObject(additionalIframeDiv15);
            additionalIframeObject15.position.set(-2400, 45, 5350);
            additionalIframeObject15.rotation.set(0, 0, 0); // Set rotation
            additionalIframeObject15.scale.set(16, 4.8, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject15.renderOrder = -1; // Lower priority
            hydraIframeObject15 = additionalIframeObject15; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject15);
          
             // Create Hydra iframe 16 - Hall 6 right wall
            const additionalIframeDiv16 = document.createElement('div');
            additionalIframeDiv16.style.width = '50px';
            additionalIframeDiv16.style.height = '50px';
            additionalIframeDiv16.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv16.style.zIndex = '-1';

            const additionalIframe16 = document.createElement('iframe');
            additionalIframe16.src = 'hydrainwebpage2.html';
            additionalIframe16.style.width = '100%';
            additionalIframe16.style.height = '100%';
            additionalIframe16.style.border = '0';
            additionalIframe16.style.pointerEvents = 'none';

            additionalIframe16.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe16.allowFullscreen = true;
            additionalIframeDiv16.appendChild(additionalIframe16);

            const additionalIframeObject16 = new CSS3DObject(additionalIframeDiv16);
            additionalIframeObject16.position.set(-2775, 45, 5290);
            additionalIframeObject16.rotation.set(0, 0, 0); // Set rotation
            additionalIframeObject16.scale.set(7, 4.8, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject16.renderOrder = -1; // Lower priority
            hydraIframeObject16 = additionalIframeObject16; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject16);
          
             // Create Hydra iframe 17 
            const additionalIframeDiv17 = document.createElement('div');
            additionalIframeDiv17.style.width = '100px';
            additionalIframeDiv17.style.height = '100px';
            additionalIframeDiv17.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv17.style.zIndex = '-1';

            const additionalIframe17 = document.createElement('iframe');
            additionalIframe17.src = 'hydrainwebpage2.html';
            additionalIframe17.style.width = '100%';
            additionalIframe17.style.height = '100%';
            additionalIframe17.style.border = '0';
            additionalIframe17.style.pointerEvents = 'none';

            additionalIframe17.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe17.allowFullscreen = true;
            additionalIframeDiv17.appendChild(additionalIframe17);

            const additionalIframeObject17 = new CSS3DObject(additionalIframeDiv17);
            additionalIframeObject17.position.set(-2875, 45, 5290);
            additionalIframeObject17.rotation.set(0, -Math.PI/2, 0); // Set rotation
            additionalIframeObject17.scale.set(10, 2.4, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject17.renderOrder = -1; // Lower priority
            hydraIframeObject17 = additionalIframeObject17; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject17);
          
             // Create Hydra iframe 18 
            const additionalIframeDiv18 = document.createElement('div');
            additionalIframeDiv18.style.width = '1000px';
            additionalIframeDiv18.style.height = '100px';
            additionalIframeDiv18.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv18.style.zIndex = '-1';

            const additionalIframe18 = document.createElement('iframe');
            additionalIframe18.src = 'hydrainwebpage2.html';
            additionalIframe18.style.width = '100%';
            additionalIframe18.style.height = '100%';
            additionalIframe18.style.border = '0';
            additionalIframe18.style.pointerEvents = 'none';

            additionalIframe18.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe18.allowFullscreen = true;
            additionalIframeDiv18.appendChild(additionalIframe18);

            const additionalIframeObject18 = new CSS3DObject(additionalIframeDiv18);
            additionalIframeObject18.position.set(-675, 45, 5590);
            additionalIframeObject18.rotation.set(0, 0, 0); // Set rotation
            additionalIframeObject18.scale.set(6, 2.4, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject18.renderOrder = -1; // Lower priority
            hydraIframeObject18 = additionalIframeObject18; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject18);
          
              // Create Hydra iframe 19 
            const additionalIframeDiv19 = document.createElement('div');
            additionalIframeDiv19.style.width = '1000px';
            additionalIframeDiv19.style.height = '1000px';
            additionalIframeDiv19.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv19.style.zIndex = '-1';

            const additionalIframe19 = document.createElement('iframe');
            additionalIframe19.src = 'hydrainwebpage2.html';
            additionalIframe19.style.width = '100%';
            additionalIframe19.style.height = '100%';
            additionalIframe19.style.border = '0';
            additionalIframe19.style.pointerEvents = 'none';

            additionalIframe19.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe19.allowFullscreen = true;
            additionalIframeDiv19.appendChild(additionalIframe19);

            const additionalIframeObject19 = new CSS3DObject(additionalIframeDiv19);
            additionalIframeObject19.position.set(1560, 0, 900);
            additionalIframeObject19.rotation.set(0, Math.PI/2, 0); // Set rotation
            additionalIframeObject19.scale.set(3, .33, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject19.renderOrder = -1; // Lower priority
            hydraIframeObject19 = additionalIframeObject19; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject19);
          
             // Create Hydra iframe 20 
            const additionalIframeDiv20 = document.createElement('div');
            additionalIframeDiv20.style.width = '500px';
            additionalIframeDiv20.style.height = '50px';
            additionalIframeDiv20.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv20.style.zIndex = '-1';

            const additionalIframe20 = document.createElement('iframe');
            additionalIframe20.src = 'hydrainwebpage2.html';
            additionalIframe20.style.width = '100%';
            additionalIframe20.style.height = '100%';
            additionalIframe20.style.border = '0';
            additionalIframe20.style.pointerEvents = 'none';

            additionalIframe20.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe20.allowFullscreen = true;
            additionalIframeDiv20.appendChild(additionalIframe20);

            const additionalIframeObject20 = new CSS3DObject(additionalIframeDiv20);
            additionalIframeObject20.position.set(-256, 45, 5350);
            additionalIframeObject20.rotation.set(0, 0, 0); // Set rotation
            additionalIframeObject20.scale.set(7.14, 4.8, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject20.renderOrder = -1; // Lower priority
            hydraIframeObject20 = additionalIframeObject20; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject20);
          
             // Create Hydra iframe 21 
            const additionalIframeDiv21 = document.createElement('div');
            additionalIframeDiv21.style.width = '1000px';
            additionalIframeDiv21.style.height = '1000px';
            additionalIframeDiv21.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv21.style.zIndex = '-1';

            const additionalIframe21 = document.createElement('iframe');
            additionalIframe21.src = 'hydrainwebpage2.html';
            additionalIframe21.style.width = '100%';
            additionalIframe21.style.height = '100%';
            additionalIframe21.style.border = '0';
            additionalIframe21.style.pointerEvents = 'none';

            additionalIframe21.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe21.allowFullscreen = true;
            additionalIframeDiv21.appendChild(additionalIframe21);

            const additionalIframeObject21 = new CSS3DObject(additionalIframeDiv21);
            additionalIframeObject21.position.set(1530, 0, 900);
            additionalIframeObject21.rotation.set(0, Math.PI/2, 0); // Set rotation
            additionalIframeObject21.scale.set(3.1, .33, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject21.renderOrder = -1; // Lower priority
            hydraIframeObject21 = additionalIframeObject21; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject21);
          
              // Create Hydra iframe 22 
            const additionalIframeDiv22 = document.createElement('div');
            additionalIframeDiv22.style.width = '1000px';
            additionalIframeDiv22.style.height = '1000px';
            additionalIframeDiv22.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv22.style.zIndex = '-1';

            const additionalIframe22 = document.createElement('iframe');
            additionalIframe22.src = 'hydrainwebpage2.html';
            additionalIframe22.style.width = '100%';
            additionalIframe22.style.height = '100%';
            additionalIframe22.style.border = '0';
            additionalIframe22.style.pointerEvents = 'none';

            additionalIframe22.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe22.allowFullscreen = true;
            additionalIframeDiv22.appendChild(additionalIframe22);

            const additionalIframeObject22 = new CSS3DObject(additionalIframeDiv22);
            additionalIframeObject22.position.set(1560, 0, 1680);
            additionalIframeObject22.rotation.set(0, Math.PI/2, 0); // Set rotation
            additionalIframeObject22.scale.set(8, .33, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject22.renderOrder = -1; // Lower priority
            hydraIframeObject22 = additionalIframeObject22; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject22);
          
             // Create Hydra iframe 23
            const additionalIframeDiv23 = document.createElement('div');
            additionalIframeDiv23.style.width = '1000px';
            additionalIframeDiv23.style.height = '1000px';
            additionalIframeDiv23.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv23.style.zIndex = '-1';

            const additionalIframe23 = document.createElement('iframe');
            additionalIframe23.src = 'hydrainwebpage2.html';
            additionalIframe23.style.width = '100%';
            additionalIframe23.style.height = '100%';
            additionalIframe23.style.border = '0';
            additionalIframe23.style.pointerEvents = 'none';

            additionalIframe23.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe23.allowFullscreen = true;
            additionalIframeDiv23.appendChild(additionalIframe23);

            const additionalIframeObject23 = new CSS3DObject(additionalIframeDiv23);
            additionalIframeObject23.position.set(1530, 0, 1680);
            additionalIframeObject23.rotation.set(0, Math.PI/2, 0); // Set rotation
            additionalIframeObject23.scale.set(5.1, .33, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject23.renderOrder = -1; // Lower priority
            hydraIframeObject23 = additionalIframeObject23; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject23);
          
             // Create Hydra iframe 24 
            const additionalIframeDiv24 = document.createElement('div');
            additionalIframeDiv24.style.width = '1000px';
            additionalIframeDiv24.style.height = '1000px';
            additionalIframeDiv24.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv24.style.zIndex = '-1';

            const additionalIframe24 = document.createElement('iframe');
            additionalIframe24.src = 'hydrainwebpage2.html';
            additionalIframe24.style.width = '100%';
            additionalIframe24.style.height = '100%';
            additionalIframe24.style.border = '0';
            additionalIframe24.style.pointerEvents = 'none';

            additionalIframe24.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe24.allowFullscreen = true;
            additionalIframeDiv24.appendChild(additionalIframe24);

            const additionalIframeObject24 = new CSS3DObject(additionalIframeDiv24);
            additionalIframeObject24.position.set(1560, 0, 3580);
            additionalIframeObject24.rotation.set(0, Math.PI/2, 0); // Set rotation
            additionalIframeObject24.scale.set(8, .33, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject24.renderOrder = -1; // Lower priority
            hydraIframeObject24 = additionalIframeObject24; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject24);
          
           // Create Hydra iframe 25
            const additionalIframeDiv25 = document.createElement('div');
            additionalIframeDiv25.style.width = '1000px';
            additionalIframeDiv25.style.height = '1000px';
            additionalIframeDiv25.style.pointerEvents = 'none'; // Click-through
            additionalIframeDiv25.style.zIndex = '-1';

            const additionalIframe25 = document.createElement('iframe');
            additionalIframe25.src = 'hydrainwebpage2.html';
            additionalIframe25.style.width = '100%';
            additionalIframe25.style.height = '100%';
            additionalIframe25.style.border = '0';
            additionalIframe25.style.pointerEvents = 'none';

            additionalIframe25.allow = 'accelerometer; display-capture; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; microphone';
            additionalIframe25.allowFullscreen = true;
            additionalIframeDiv25.appendChild(additionalIframe25);

            const additionalIframeObject25 = new CSS3DObject(additionalIframeDiv25);
            additionalIframeObject25.position.set(1530, 0, 3850);
            additionalIframeObject25.rotation.set(0, Math.PI/2, 0); // Set rotation
            additionalIframeObject25.scale.set(3, .33, 1); // Increase size in 3D without increasing resolution
            additionalIframeObject25.renderOrder = -1; // Lower priority
            hydraIframeObject25 = additionalIframeObject25; // Store Hydra iframe object globally
            cssScene.add(additionalIframeObject25);
          
          
    const mainIframeLoader = new IframeLazyLoader(iframeObject, 'index.html');
    const hydraLoader1 = new IframeLazyLoader(additionalIframeObject, 'hydrainwebpage2.html');
    const hydraLoader2 = new IframeLazyLoader(additionalIframeObject2, 'hydrainwebpage2.html');
    const hydraLoader3 = new IframeLazyLoader(additionalIframeObject3, 'hydrainwebpage2.html');
    const hydraLoader4 = new IframeLazyLoader(additionalIframeObject4, 'hydrainwebpage2.html');
    const hydraLoader5 = new IframeLazyLoader(additionalIframeObject5, 'hydrainwebpage2.html');
    const hydraLoader6 = new IframeLazyLoader(additionalIframeObject6, 'hydrainwebpage2.html');
    const hydraLoader11 = new IframeLazyLoader(additionalIframeObject11, 'hydrainwebpage2.html');
    const hydraLoader12 = new IframeLazyLoader(additionalIframeObject12, 'hydrainwebpage2.html');
    const hydraLoader13 = new IframeLazyLoader(additionalIframeObject13, 'hydrainwebpage2.html');
    const hydraLoader14 = new IframeLazyLoader(additionalIframeObject14, 'hydrainwebpage2.html');
    const hydraLoader15 = new IframeLazyLoader(additionalIframeObject15, 'hydrainwebpage2.html');
    const hydraLoader16 = new IframeLazyLoader(additionalIframeObject16, 'hydrainwebpage2.html');
    const hydraLoader17 = new IframeLazyLoader(additionalIframeObject17, 'hydrainwebpage2.html');
    const hydraLoader18 = new IframeLazyLoader(additionalIframeObject18, 'hydrainwebpage2.html');
    const hydraLoader19 = new IframeLazyLoader(additionalIframeObject19, 'hydrainwebpage2.html');
    const hydraLoader20 = new IframeLazyLoader(additionalIframeObject20, 'hydrainwebpage2.html');
    const hydraLoader21 = new IframeLazyLoader(additionalIframeObject21, 'hydrainwebpage2.html');
    const hydraLoader22 = new IframeLazyLoader(additionalIframeObject22, 'hydrainwebpage2.html');
    const hydraLoader23 = new IframeLazyLoader(additionalIframeObject23, 'hydrainwebpage2.html');
    const hydraLoader24 = new IframeLazyLoader(additionalIframeObject24, 'hydrainwebpage2.html');
    const hydraLoader25 = new IframeLazyLoader(additionalIframeObject25, 'hydrainwebpage2.html');



    if (!window.iframeLoaders) {
        window.iframeLoaders = [];
    }
    window.iframeLoaders.push(
        mainIframeLoader,
        hydraLoader1,
        hydraLoader2,
        hydraLoader3,
        hydraLoader4,
        hydraLoader5,
        hydraLoader6,
        hydraLoader11,
        hydraLoader12,
        hydraLoader13,
        hydraLoader14,
        hydraLoader15,
        hydraLoader16,
        hydraLoader17,
        hydraLoader18,
        hydraLoader19,
        hydraLoader20,
        hydraLoader21,
        hydraLoader22,
        hydraLoader23,
        hydraLoader24,
        hydraLoader25
    ); 
                    
 //    const positionalAudioAnalyzer = audioContext.createAnalyser();
 //    positionalAudioAnalyzer.fftSize = 2048;

            // Add positional audio
            const positionalAudio = new THREE.PositionalAudio(listener);
            audioLoader.load('Sound_22.mp3', function (buffer) {
                positionalAudio.setBuffer(buffer);    
                positionalAudio.setRefDistance(1);        
                positionalAudio.position.set(1220, 50, -1450);
                positionalAudio.setDistanceModel('linear');
                positionalAudio.setRolloffFactor(8);
                positionalAudio.setMaxDistance(800);
                positionalAudio.setVolume(1);
                positionalAudio.loop = true;
                positionalAudio.play();

          //      positionalAudio.getOutput().connect(analyser);
          //      positionalAudio.getOutput().connect(audioContext.destination);

                // Bring up the volume after short delay, giving all parameters time to load
                setTimeout(() => {
                    positionalAudio.setVolume(1);
                },  100); // Wait 100ms
            });
            scene.add(positionalAudio);
          
          // Add a new positional sound source for the bell
              const newSoundSource = new THREE.PositionalAudio(listener);
              audioLoader.load('Sound_22.mp3', function (buffer) {

                  newSoundSource.setBuffer(buffer);
                  newSoundSource.setRefDistance(1);
               //   newSoundSource.position.set(1220, 50, -1450);
                  newSoundSource.position.set(0, 50, 5250);
                  newSoundSource.setDistanceModel('linear');
                  newSoundSource.setRolloffFactor(8);
                  newSoundSource.setMaxDistance(850);
                  newSoundSource.setVolume(1);
                  newSoundSource.loop = true;
                  newSoundSource.play();
                  newSoundSource.getOutput().connect(positionalAudioAnalyser);
                
                // Bring up the volume after short delay, giving all parameters time to load
                setTimeout(() => {
                    positionalAudio.setVolume(1);
                },  100); // Wait 100ms
                
              });
              
              scene.add(newSoundSource);
              
    
          const newSoundSource2 = new THREE.PositionalAudio(listener);
              audioLoader.load('sax_clicks_mono.mp3', function (buffer) {

                  newSoundSource2.setBuffer(buffer);
                  newSoundSource2.setRefDistance(1);
              //    newSoundSource2.position.set(-1420, 50, -1400);
                  newSoundSource2.position.set(-1450, 50, 1000);
                  newSoundSource2.setDistanceModel('linear');
                  newSoundSource2.setRolloffFactor(8);
                  newSoundSource2.setMaxDistance(1650);
                  newSoundSource2.setVolume(1);
                  newSoundSource2.loop = true;
                  newSoundSource2.play();
                  newSoundSource2.getOutput().connect(positionalAudioAnalyser);
                
                // Bring up the volume after short delay, giving all parameters time to load
                setTimeout(() => {
                    positionalAudio.setVolume(1);
                },  100); // Wait 100ms
                
              });
              
              scene.add(newSoundSource2);
          
          
           const newSoundSource3 = new THREE.PositionalAudio(listener);
              audioLoader.load('sax_clicks_mono.mp3', function (buffer) {

                  newSoundSource3.setBuffer(buffer);
                  newSoundSource3.setRefDistance(1);
                  newSoundSource3.position.set(-2420, 50, 3000);
                  newSoundSource3.setDistanceModel('linear');
                  newSoundSource3.setRolloffFactor(8);
                  newSoundSource3.setMaxDistance(1650);
                  newSoundSource3.setVolume(1);
                  newSoundSource3.loop = true;
                  newSoundSource3.play();
                  newSoundSource3.getOutput().connect(positionalAudioAnalyser);
                
                // Bring up the volume after short delay, giving all parameters time to load
                setTimeout(() => {
                    positionalAudio.setVolume(1);
                },  100); // Wait 100ms
                
              });
              
              scene.add(newSoundSource3);
          
             const newSoundSource4 = new THREE.PositionalAudio(listener);
              audioLoader.load('sam-sax-air-noise.mp3', function (buffer) {

                  newSoundSource4.setBuffer(buffer);
                  newSoundSource4.setRefDistance(1);
                  newSoundSource4.position.set(1590, 50, 1000);
                  newSoundSource4.setDistanceModel('linear');
                  newSoundSource4.setRolloffFactor(.9);
                  newSoundSource4.setMaxDistance(1650);
                  newSoundSource4.setVolume(6);
                  newSoundSource4.setDirectionalCone(60, 120, .1);
                  newSoundSource4.rotation.set(-Math.PI/4, -Math.PI/4, 0);
                  newSoundSource4.loop = true;
             //     newSoundSource4.play();
             //     newSoundSource4.getOutput().connect(positionalAudioAnalyser);

                  const airNoiseHelper = new PositionalAudioHelper(newSoundSource4, 100);
            //      newSoundSource4.add(airNoiseHelper);
                
                // Bring up the volume after short delay, giving all parameters time to load
                setTimeout(() => {
                    positionalAudio.setVolume(6);
                },  100); // Wait 100ms
                
              });
              
              scene.add(newSoundSource4);

          const newSoundSource5 = new THREE.PositionalAudio(listener);
            audioLoader.load('sam-quiet-key-clicks.mp3', function (buffer) {

                newSoundSource5.setBuffer(buffer);
                newSoundSource5.setRefDistance(1);
                newSoundSource5.position.set(1500, 50, 2000);
                newSoundSource5.setDistanceModel('linear');
                newSoundSource5.setRolloffFactor(.9);
                newSoundSource5.setMaxDistance(1650);
                newSoundSource5.setVolume(2);
                newSoundSource5.setDirectionalCone(60, 120, .1);
                newSoundSource5.rotation.set(-Math.PI/4, 3*Math.PI/4, 0);
                newSoundSource5.loop = true;
          //      newSoundSource5.play();
          //      newSoundSource5.getOutput().connect(positionalAudioAnalyser);

                const quietClicksHelper = new PositionalAudioHelper(newSoundSource5, 100);
          //      newSoundSource5.add(quietClicksHelper);

              // Bring up the volume after short delay, giving all parameters time to load
              setTimeout(() => {
                  positionalAudio.setVolume(2);
              },  100); // Wait 100ms

            });

            scene.add(newSoundSource5);
          
        }
      
        // Create iframes and audio sources
        for (let i = 0; i < iframePositions.length; i++) {
            const pos = iframePositions[i];
            const rot = i === 0 ? [0, -Math.PI/2, 0] : 
                        i === 1 ? [0, 10*Math.PI/6, 0] : 
                        i === 2 ? [0, Math.PI / 2, 0] : 
                                  [0, -Math.PI / 2, 0];
            createIframeWithAudio(pos, rot, soundList[i]);
        }

        function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const pixelRatio = window.devicePixelRatio;
            const width = canvas.clientWidth * pixelRatio | 0;
            const height = canvas.clientHeight * pixelRatio | 0;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
                renderer.setSize(width, height, false);
                cssRenderer.setSize(width, height);
            }
            return needResize;
        }
   
    const timerDiv = document.createElement('div');
      timerDiv.style.position = 'fixed';
      timerDiv.style.top = '1rem';
      timerDiv.style.right = '1rem';
      timerDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
      timerDiv.style.color = 'white';
      timerDiv.style.padding = '0.5rem 1rem';
      timerDiv.style.borderRadius = '0.5rem';
      timerDiv.style.fontFamily = 'monospace';
      timerDiv.style.fontSize = '1.25rem';
      document.body.appendChild(timerDiv);

      // Timer logic
      let seconds = -9;
      const formatTime = (num) => num.toString().padStart(2, '0');

      function updateTimer() {
          const minutes = Math.floor(seconds / 60);
          const remainingSeconds = seconds % 60;
          timerDiv.textContent = `${formatTime(minutes)}:${formatTime(remainingSeconds)}`;
          seconds++;
      }

// Start the timer
const timer = setInterval(updateTimer, 1000);
updateTimer(); // Call once immediately to show 00:00    
  
      
  //Gamepad setup
   function handleGamepadInput() {
    const gamepads = navigator.getGamepads();
    const gp = gamepads[0]; // Assuming a single gamepad

    if (gp) {
        const leftStickX = gp.axes[0]; // Left stick horizontal
        const leftStickY = gp.axes[1]; // Left stick vertical
        const rightStickX = gp.axes[2]; // Right stick horizontal
        const rightStickY = gp.axes[3]; // Right stick vertical

        const moveSpeed = 0; // Adjust for smoother motion control 
        const lookSpeed = 0.09; // Lower for slower camera rotation

        // Move camera forward/backward
        if (Math.abs(leftStickY) > 0.1) {
            controls.moveForward(-leftStickY * moveSpeed);
        }
        // Move camera left/right
        if (Math.abs(leftStickX) > 0.1) {
            controls.moveRight(leftStickX * moveSpeed);
        }

        // Smooth rotation using rotateOnAxis
        const yaw = new THREE.Vector3(0, 1, 0); // Yaw axis (up)
        const pitch = new THREE.Vector3(1, 0, 0); // Pitch axis (right)

        // Rotate around the Y-axis (yaw)
        if (Math.abs(rightStickX) > 0.1) {
            camera.rotateOnWorldAxis(yaw, -rightStickX * lookSpeed);
        }

        // Rotate around the X-axis (pitch), with clamping
        if (Math.abs(rightStickY) > 0.1) {
            camera.rotateOnAxis(pitch, -rightStickY * lookSpeed);
           

             // Apply pitch clamping to prevent gimbal lock (roll and excessive pitch)
            const maxPitch = Math.PI / 2 - 0.01; // Slightly less than 90 degrees
            const minPitch = -Math.PI / 2 + 0.01;
            const pitchQuaternion = new THREE.Quaternion().setFromEuler(camera.rotation);
            pitchQuaternion.x = Math.max(minPitch, Math.min(maxPitch, pitchQuaternion.x));
            camera.rotation.setFromQuaternion(pitchQuaternion);
        }

        // Apply yaw clamping (optional, depending on your game design)
        const maxYaw = Math.PI - 0.05;  // +180 degrees
        const minYaw = -Math.PI + 0.05; // -180 degrees
        const yawQuaternion = new THREE.Quaternion().setFromEuler(camera.rotation);
        yawQuaternion.y = Math.max(minYaw, Math.min(maxYaw, yawQuaternion.y));
        camera.rotation.setFromQuaternion(yawQuaternion);          
        
    }
}

//End of gamepad setup

let speed = 0; // Movement speed
let rms = 0;
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

//Start microphone input capture and analysis

async function setupAudioInput() {
    try {
        // Get user media permission
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
const source = threeJsAudioContext.createMediaStreamSource(stream);
source.connect(positionalAudioAnalyser);
positionalAudioAnalyser.fftSize = 2048;
const bufferLength = positionalAudioAnalyser.frequencyBinCount;
const dataArray = new Float32Array(bufferLength);
const frequencies = new Float32Array(bufferLength);
let targetSpeed = 0;
const speedFactor = 0.3;
const AMPLITUDE_THRESHOLD = 0.005;
let previousFrequencies = new Float32Array(bufferLength);

function calculateSpectralCentroid(frequencyData) {
    let numerator = 0;
    let denominator = 0;
    for (let i = 0; i < frequencyData.length; i++) {
        const frequency = i * audioContext.sampleRate / (2 * frequencyData.length);
        const magnitude = Math.abs(frequencyData[i]);
        numerator += frequency * magnitude;
        denominator += magnitude;
    }
    return denominator !== 0 ? numerator / denominator : 0;
}

function calculateSpectralSpread(frequencyData, centroid) {
    let numerator = 0;
    let denominator = 0;
    for (let i = 0; i < frequencyData.length; i++) {
        const frequency = i * audioContext.sampleRate / (2 * frequencyData.length);
        const magnitude = Math.abs(frequencyData[i]);
        numerator += magnitude * Math.pow(frequency - centroid, 2);
        denominator += magnitude;
    }
    return denominator !== 0 ? Math.sqrt(numerator / denominator) : 0;
}

function calculateSpectralKurtosis(frequencyData, centroid, spread) {
            let numerator = 0, denominator = 0;
            for (let i = 0; i < frequencyData.length; i++) {
                const frequency = i * audioContext.sampleRate / (2 * frequencyData.length);
                const magnitude = Math.abs(frequencyData[i]);
                numerator += magnitude * Math.pow((frequency - centroid) / spread, 4);
                denominator += magnitude;
            }
            return denominator !== 0 ? (numerator / denominator) - 3 : 0; // Subtract 3 to center at zero
        }

        function calculateSpectralFlux(currentFrequencies, previousFrequencies) {
            let sum = 0;
            for (let i = 0; i < currentFrequencies.length; i++) {
                const diff = currentFrequencies[i] - previousFrequencies[i];
                sum += diff * diff;
            }
            return Math.sqrt(sum) / currentFrequencies.length;
        }

function analyzeAudio() {
    positionalAudioAnalyser.getFloatTimeDomainData(dataArray);
    let sumSquares = 0;
    for (let i = 0; i < dataArray.length; i++) {
        sumSquares += dataArray[i] * dataArray[i];
    }
    rms = Math.sqrt(sumSquares / dataArray.length);
//    console.log("Amplitude (RMS):", rms);

    if (rms >= AMPLITUDE_THRESHOLD) {
        positionalAudioAnalyser.getFloatFrequencyData(frequencies);
        const linearFrequencies = frequencies.map(db => Math.pow(10, db / 20));
        const centroid = calculateSpectralCentroid(linearFrequencies);
        const spread = calculateSpectralSpread(linearFrequencies, centroid);
        const flux = calculateSpectralFlux(linearFrequencies, previousFrequencies);
        const kurtosis = calculateSpectralKurtosis(linearFrequencies, centroid, spread);
        
        if (centroid > 0) {
       //   targetSpeed = ((((centroid + spread)/2) - 1500) / 2) + ((kurtosis - 0.5) * 100);
        //    targetSpeed = ((0.99 - kurtosis) * 70000) + ((Math.sqrt(spread) - 50) * 7) + ((flux - 0.01) * 700);
        //    targetSpeed = (Math.sqrt(spread) - 55) * 7;
      //  targetSpeed = (((centroid / 5000) * 600 - 300) + ((spread / 5000) * 400 - 200) - ((1-kurtosis) * 4000) + (flux * 10000 - 50));
       //     targetSpeed = (((spread - 2500)/50) + (flux*10000000) - (kurtosis*2)) * 5 + 300;
         //   targetSpeed = (((spread - 2500)/100) - (kurtosis)) * 3;
         // targetSpeed = (centroid - 1000) * 0.5;
         targetSpeed = (((spread - 2500)/50) + (flux*10000000) - (kurtosis*2)) * 3;

       //     console.log('Spectral Centroid:', centroid/100);
            console.log('Spectral Spread:', ((spread - 2500)/50));
            console.log('Spectral Flux:', flux*10000000);
            console.log('Spectral Kurtosis:', -kurtosis*2);
            console.log('Target Speed:', targetSpeed);
        }
        previousFrequencies.set(linearFrequencies);
    } else {
        targetSpeed = 0;
    }
    
    speed += (targetSpeed - speed) * speedFactor;
    requestAnimationFrame(analyzeAudio);
}

analyzeAudio();

        // Wait for 10 seconds before starting audio analysis
     //   console.log('Waiting for 10 seconds before processing audio...');
        await delay(10000);
     //   console.log('Starting audio analysis...');
        
        // Start the audio analysis
        analyzeAudio();

    } catch (err) {
        console.error('Error accessing microphone:', err);
    } 
}
    
function animate() {
    const delta = clock.getDelta();
    handleGamepadInput();
  
    // Update iframe visibility
    if (window.iframeLoaders) {
        window.iframeLoaders.forEach(loader => {
            loader.updateVisibility(camera);
        });
    }
  
    move.forward = true;
    
    if (mixer) {
        mixer.update(delta);
    }
  
     if (mixer2) {
        mixer2.update(delta);
    }

    if (mixer3) {
        mixer3.update(delta);
    }

    if (mixer4) {
        mixer4.update(delta);
    }

    if (mixer5) {
        mixer5.update(delta);
    }
    
 //   const speed = 150 * delta;
  
    const baseMoveSpeed = .6; // Base speed multiplier
    const maxSpeed = 800
    const minSpeed = -800;
 //   const minSpeed = 100
    const clampedSpeed = Math.max(minSpeed, Math.min(speed, maxSpeed));
    const adjustedSpeed = clampedSpeed * delta * baseMoveSpeed;
  
    // Store initial position
    const initialPosition = camera.position.clone();
    let finalPosition = initialPosition.clone();
    
    // Calculate the movement vector
    const moveVector = new THREE.Vector3(0, 0, 0);
    
    // Get the camera's forward and right vectors
    const forward = new THREE.Vector3();
    const right = new THREE.Vector3();
    controls.getDirection(forward);
    right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
    
    // Normalize vectors to handle diagonal movement correctly
    forward.normalize();
    right.normalize();
    
    // Add movement components
    if (move.forward) moveVector.add(forward.multiplyScalar(adjustedSpeed));
    if (move.backward) moveVector.sub(forward.multiplyScalar(adjustedSpeed));
    if (move.left) moveVector.sub(right.multiplyScalar(adjustedSpeed));
    if (move.right) moveVector.add(right.multiplyScalar(adjustedSpeed));
    
    // Test moving along both axes separately
    if (moveVector.length() > 0) {
        // Try X movement
        const xMovement = new THREE.Vector3(moveVector.x, 0, 0);
        camera.position.add(xMovement);
        updateBoundingBoxes();
        
        const hitXRed = cameraBoundingBox.intersectsBox(redBoxBoundingBox);
        const hitXGreen = cameraBoundingBox.intersectsBox(greenBoxBoundingBox);
        const hitX3 = cameraBoundingBox.intersectsBox(boundingBox3);
        const hitX4 = cameraBoundingBox.intersectsBox(boundingBox4);
        const hitX5 = cameraBoundingBox.intersectsBox(boundingBox5);
        const hitX6 = cameraBoundingBox.intersectsBox(boundingBox6);
        const hitX7 = cameraBoundingBox.intersectsBox(boundingBox7);
        const hitX9 = cameraBoundingBox.intersectsBox(boundingBox9);
        const hitX10 = cameraBoundingBox.intersectsBox(boundingBox10);
        const hitX11 = cameraBoundingBox.intersectsBox(boundingBox11);
        const hitX12 = cameraBoundingBox.intersectsBox(boundingBox12);
        const hitX13 = cameraBoundingBox.intersectsBox(boundingBox13);
        const hitX14 = cameraBoundingBox.intersectsBox(boundingBox14);
        const hitX15 = cameraBoundingBox.intersectsBox(boundingBox15);
        const hitX16 = cameraBoundingBox.intersectsBox(boundingBox16);

        
        if (hitXRed || hitXGreen || hitX3 || hitX4 || hitX5 || hitX6 || hitX7 || hitX9 || hitX10 || hitX11 || hitX12 || hitX13 || hitX14 || hitX15 || hitX16 ) {
            // Revert X movement if there's a collision
            camera.position.sub(xMovement);
        } else {
            finalPosition.add(xMovement);
        }
        
        //Test Z movement
        const zMovement = new THREE.Vector3(0, 0, moveVector.z);
        camera.position.copy(initialPosition);
        camera.position.add(zMovement);
        updateBoundingBoxes();
        
        const hitZRed = cameraBoundingBox.intersectsBox(redBoxBoundingBox);
        const hitZGreen = cameraBoundingBox.intersectsBox(greenBoxBoundingBox);
        const hitZ3 = cameraBoundingBox.intersectsBox(boundingBox3);
        const hitZ4 = cameraBoundingBox.intersectsBox(boundingBox4);
        const hitZ5 = cameraBoundingBox.intersectsBox(boundingBox5);
        const hitZ6 = cameraBoundingBox.intersectsBox(boundingBox6);
        const hitZ7 = cameraBoundingBox.intersectsBox(boundingBox7);
        const hitZ9 = cameraBoundingBox.intersectsBox(boundingBox9);
        const hitZ10 = cameraBoundingBox.intersectsBox(boundingBox10);
        const hitZ11 = cameraBoundingBox.intersectsBox(boundingBox11);
        const hitZ12 = cameraBoundingBox.intersectsBox(boundingBox12);
        const hitZ13 = cameraBoundingBox.intersectsBox(boundingBox13);
        const hitZ14 = cameraBoundingBox.intersectsBox(boundingBox14);
        const hitZ15 = cameraBoundingBox.intersectsBox(boundingBox15);
        const hitZ16 = cameraBoundingBox.intersectsBox(boundingBox16);
      
        if (hitZRed || hitZGreen || hitZ3 || hitZ4 || hitZ5 || hitZ6 || hitZ7 || hitZ9 || hitZ10 || hitZ11 || hitZ12 || hitZ13 || hitZ14 || hitZ15 || hitZ16) {
            // Revert Z movement if there's a collision
            camera.position.sub(zMovement);
        } else {
            finalPosition.add(zMovement);
        }
        
        // Set final position
        camera.position.copy(finalPosition);
        updateBoundingBoxes();
    }
    
    if (resizeRendererToDisplaySize(renderer)) {
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
    }
    
    updateBoundingBoxes();
      
    renderer.render(scene, camera);
    cssRenderer.render(cssScene, camera);
    requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
    }
    
</script>
</body>
</html>
